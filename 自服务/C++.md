### 编译器

text（源文件）到（二进制文件）

c++编译器： 将文本变成中继格式obj，obj再传给linker

1. pre-process（预处理）

2. tokenizing（标记解释）和parsing（解析）阶段

3. 创建abstract syntax tree（抽象语法树）

   

 编译单元：根据C++标准，每一个CPP文件就是一个编译单元。每个编译单元之间是相互独立并且互相不可知。 

## 基础语法

### 变量

`bool` 占一个字节，内存寻址时，只能寻址到字节里

### 头文件

以#号开头的语句都被称为一个预处理命令，叫做预处理指令，这意味着他将在这个文件被编译之前被c++的预处理评估。

`#pragma once` ：（头文件保护符）pragma是一个被输入到预处理器的指令。意思是只能include头文件一次，防止我们把单个头文件多次include到一个cpp文件里。

### 指针

指针是一个数字，它存储一个内存地址。

### 引用

声明语法： `类型表示符&引用名=变量名`

`int a=0;	int& ref=a;`

引用变量是一个别名，即某个已存在变量的另外一个名字，一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。 

说明：

1. `&`在此不是求地址运算，而是起标识作用，==实际上是变量类型的一部分int&==

2. 类型标识符是指目标变量的类型。
3. ==声明引用时，必须同时对其进行初始化。==
4. 引用声明完毕后，相当于目标变量名有两个名称，即该目标原名称和引用名，且不能再把该引用名作为其他变量名的别名。

5. 声明一个引用，不是新定义了一个变量，它只表示该引用名是目标变量名的一个别名，它本身不是一种数据类型，因此引用本身不占存储单元，系统也不给引用分配存储单元。故：对引用求地址，就是对目标变量求地址。&ra与&a相等。
6. 不能建立数组的引用。因为数组是一个由若干个元素所组成的集合，所以无法建立一个数组的别名。

应用：

1. 作为参数

   传递引用给函数与传递指针的效果是一样的。这时，被调函数的形参相当于原来实参变量或对象的一个别名来使用，所以在函数中对形参变量的操作就是对其相应的目标对象（在主调函数中）的操作。

2. 使用引用的参数，在内存中没有产生实参的副本，而是直接对实参进行操作。
3. 使用指针也可以达到同样效果，但阅读性较差（要解引用，加*） 

https://www.cnblogs.com/Mr-xu/archive/2012/08/07/2626973.html

```c++
/***格式******************/
void fun(int&x ,int&y); 
fun(a,b); 
/**********************/
void add(int&value){
    value++;
}
int main(){
    int a=4;
    add(a) ;
}
```



###  const_cast

 C++运算符，用来去除复合类型中const和volatile的属性（没有真正去除）

==变量本身的const属性是不能去除的，想要修改变量的值，一般去除指针或引用的const属性，再进行间接修改== 

```c++
int main(){
    const int a = 100 ;
    int *b= const_cast <int*>(&a) ;
    *b= 500 ;
    printf("a= %d b=%d  ",a,*b ) ;
    return 0 ; 
}
```

### using namespace std

 是指标识符的各种可见范围，C++标准库中的所有标识符都被定义在一个名为`std`的`namespace`中



### new/delete 关键字

完全取代了 C语言中的malloc和free，完成对堆内存的创建和释放。 

看示例： 

```c++
    int  *str= new int [100]{4} ; 
    for(int i=0;i<100;i++)
    cout<<str[i]<<endl; 

    const char *c=new char[100]{'c','h','i'} ; 
    cout<<c<<endl;
    delete[]c; 
    delete[]str ;  
```

示例中： str[] 数组只有第一个被初始化成了4； 如果delete 前没有加[]，那么也就只有第一个能被释放掉。 